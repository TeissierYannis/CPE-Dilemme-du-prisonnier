<h1 align="center">CPE Lyon - 3ICS - Ann√©e 2021/22
D√©veloppement informatique ‚Äì 2
Projet </h1>

<div align="center">

[![CTF](https://img.shields.io/badge/CPE_LYON-2021-blue.svg)](https://france-cybersecurity-challenge.fr/)
[![CTF](https://img.shields.io/badge/Language-C-yellow.svg)](#)
[![CTF](https://img.shields.io/badge/Category-Network/C-red.svg)](#)

</div>


--- 

## üìù Table des mati√®res

- [Pr√©sentation de l'√©quipe](#team)
- [Organisation du travail dans le groupe](#work_distribution)
- [M√©thodologie de d√©veloppement](#methodology)
- [Avancement du projet et justification des choix](#justify)
- [ Difficult√©s rencontr√©es](#difficulties)
- [Bilan](#bilan)

<hr>

<h1>Travail effectu√©</h1>

## üßê Pr√©sentation de l'√©quipe <a name = "team"></a>

Notre √©quipe est compos√©e de 4 √©tudiants :
- Nicola : Originaire de BTS ...
- Alexis : Originaire de BTS ...
- Tarik : Originaire de BTS ...
- Yannis : Originaire de BTS SIO Option SLAM

## üßê Organisation du travail dans le groupe <a name = "work_distribution"></a>

Avant de commencer √† coder, nous avons √©crit sur papier les diff√©rents points cl√©s √† r√©aliser afin d‚Äô√©tablir les objectifs du projet. Une fois le cahier des charges r√©dig√©, nous avons choisi de se r√©partir, entre chaque membre du groupe, les grandes parties du projet
- Partie client :
  - R√©alisation de l‚Äôinterface graphique - Tarik SAGLAMER 
  - R√©alisation de la communication client - Alexis REVOL
- Partie serveur :
  - R√©alisation de la logistique du jeu - Nicola PIEMONTESE
  - R√©alisation de la communication serveur - Yannis TEISSIER
  
Ainsi chaque membre a pu se concentrer sur la r√©alisation de sa partie, cependant les parties √©tant √©troitement li√©es, une communication permanente a √©t√© mise en place afin de s‚Äôassurer de la coh√©rence entre chaque branche du projet.

## üßê M√©thodologie de d√©veloppement <a name = "methodology"></a>

Afin de s'organiser et de r√©aliser le projet, nous avons commenc√© par √©crire les diff√©rents points √† r√©aliser. ( Cf Annexe 1)

Dans un second temps, nous nous sommes organis√©s sur Github √† l'aide de diff√©rentes branches.

Une branche main vide dans le cas o√π une mauvaise manipulation venait √† √™tre faite. Une branche client pour la partie production client. Une branche serveur pour la partie production serveur. Une branche par personne pour la partie de d√©veloppement.
Nous avons √©galement cr√©√© un serveur discord afin de communiquer efficacement sur le projet.

Notre approche du travail s'est bas√©e sur une m√©thodologie de d√©veloppement agile personnalis√©e. Les heures de cours √©taient principalement utilis√©es pour la correction de bug, la discussion, le code review et la r√©daction des points √† r√©aliser et des am√©liorations √† apporter. Pour la partie d√©veloppement, nous avons utilis√© nos heures libres.
Dans le cas ou un bug √©tait d√©tect√©, deux solutions ont √©t√© propos√©es :
- R√©solution directe par la personne ayant d√©tect√© le bug
- R√©solution par la personne ayant d√©velopp√© le code

R√©guli√®rement, nous faisions des codes reviews nous permettant de mettre en commun le travail r√©alis√© et de voir les changements effectu√©s par les autres membres.

## üßê Avancement du projet et justification des choix <a name = "justify"></a>

<h4>Justification des choix</h4>

Pour √©tablir la communication entre un client et le serveur, nous avons choisi d‚Äôutiliser les sockets afin de transmettre des structures contenant les informations pertinentes √† manipuler et traiter. Le client et le serveur poss√©dants les m√™mes structures cela permet de s‚Äôassurer que la forme de l‚Äôinformation envoy√©e sera la m√™me que celle de l‚Äôinformation attendue √† la r√©ception. Nous avons choisi d‚Äô√©tablir un protocole de communication entre le client et le serveur afin que la communication entre chaque partie suive une ligne identique.

Pour r√©aliser l‚Äôinterface graphique, nous avons utilis√© GTK qui permet de r√©aliser des fen√™tres graphiques personnalisables ce qui est id√©al pour la r√©alisation du plateau de jeu. L‚Äôinterface est compos√©e des boutons pour jouer (trahir et collaborer) ainsi que de zones de textes permettant d‚Äôafficher les informations utiles pour le joueur. Ainsi lorsque dans le protocole de communication client/serveur nous souhaitons transmettre le choix de jeu r√©alis√© par le client nous √©coutons sur quel bouton le joueur √† cliqu√© afin d‚Äôenregistrer et de traiter l‚Äôinformation. Lorsque le client r√©ceptionne des informations du serveur il peut alors les fournir √† l‚Äôinterface graphique afin de les afficher

Pour r√©aliser la logistique du jeu, nous avons choisi d‚Äô√©tablir des r√®gles qui permettent ainsi de traiter les informations  de mani√®re efficace en s‚Äôassurant de conserver leur pertinence. Nous avons √©galement choisi de r√©aliser des fichiers de configurations  lues au lancement du jeu, ceux-ci contenant des informations telles que l‚Äôadresse du serveur, le port, des r√®gles du jeu... Cela permet, en cas de changement de l‚Äôadresse du serveur ou de certaines r√®gles du jeu, de ne pas avoir √† modifier les programmes ce qui facilite l‚Äô√©volutivit√© et l‚Äôadaptation aux changements des programmes.

<h4>Justification des choix</h4>

Aujourd‚Äôhui le client et le serveur sont capables de lire leurs fichiers de configuration r√©ceptifs, le serveur √©coute les connexions entrantes et les place dans une file d‚Äôattente. Lorsque 2 clients sont disponibles dans la file d'attente, il lance la communication permettant de jouer en fournissant les informations de d√©but de partie au client.

Ainsi lorsque le client lance le jeu il est inform√© par un message que la partie se charge le temps que le serveur lui informe qu‚Äôune partie va d√©buter. Une fois le jeu commenc√© le client indique que le joueur peut jouer en cliquant sur un bouton, puis lors d‚Äôun clic il envoie l‚Äôinformation au serveur. Le serveur attend de recevoir les r√©ponses des 2 joueurs, le joueur est alors inform√© qu‚Äôil est en attente de la r√©ponse de l‚Äôadversaire s‚Äôil n‚Äôa pas encore jou√©.

Lorsque le serveur a re√ßu les r√©ponses des 2 joueurs, ils les traitent afin d‚Äô√©tablir un score et il transmet au client le r√©sultat du round, le client peut alors fournir √† l‚Äôinterface graphique le r√©sultat du round (choix de l‚Äôadversaire, score de chaque joueur, etc‚Ä¶) afin de les afficher pour que le joueur soit inform√© du r√©sultat du round et de ce qui a √©t√© effectu√©. Le joueur peut observer les r√©sultats du round (durant 3 secondes) puis il est inform√© qu‚Äôun nouveau round commence et le sch√©ma se r√©p√®te.

Lorsque le serveur indique au client que la partie est termin√©e, le client affich√© sur l‚Äôinterface graphique un bouton pour rejouer ainsi que le nom du gagnant, si le joueur clique dessus alors le client est replac√© dans la file d‚Äôattente du serveur, s‚Äôil quitte la partie le serveur ferme la connexion du client.

Ainsi plusieurs joueurs peuvent jouer au dilemme du prisonnier en r√©seau (multi-joueurs) et peuvent recommencer des parties afin de tomber contre d‚Äôautres adversaires !

Enfin les r√©sultats d‚Äôune partie sont aussi stock√©s dans un fichier CSV pouvant √™tre lu avec un logiciel de tableur comme Excel.

## üßê Difficult√©s rencontr√©es <a name = "difficulties"></a>

Durant la r√©alisation du projet nous avons √©t√© confront√©s √† diff√©rentes difficult√©s. Tout d‚Äôabord nous avons rencontr√© des difficult√©s li√©es √† la programmation. En effet nous avons d√ª nous coordonner puisque chacun d‚Äôentre nous √† des mani√®res diff√©rentes de programmer, ainsi nous avons d√ª adapter certaines parties du code afin qu'elles fonctionnent avec le reste du projet. De plus, nous avons d√ª r√©soudre plusieurs probl√®mes li√©s √† des bugs de m√©moire.

Nous avons aussi pass√© du temps √† √©tablir une communication entre le serveur et les clients stables . En effet, nous devions r√©aliser une connexion permettant l‚Äôenvoi de structure complexe, avec un protocole clair et simple.

D'autres difficult√©s li√©es √† la m√©thodologie sont aussi apparues. Ainsi puisque que toutes nos parties sont finalement li√©es entre elles, il nous est apparu n√©cessaire de bien se coordonner et de se tenir √† jour des modifications des autres membres afin que les changements ne perturbent pas l'avanc√©e des autres.

Concernant la partie graphique nous nous sommes mis d‚Äôaccord sur une interface graphique qui soit simple et avons d√ª l'adapter afin de pouvoir la faire communiquer avec le client.

Finalement plusieurs difficult√©s √©taient dues au fait qu‚Äôaucun de nous quatre n‚Äôavait auparavant d√©j√† programm√© d‚Äôinterfaces graphiques ou de communication client-serveur en C.

## üßê Bilan <a name = "bilan"></a>

Au cours de ce projet nous avons su mettre en avant les comp√©tences acquises au cours de ce module de d√©veloppement et les compl√©ter en recherchant des solutions pour r√©soudre des probl√®mes sp√©cifiques au projet. Ce projet a n√©cessit√© de l‚Äôautonomie sur les r√©flexions et les choix des m√©thodes √† apporter pour r√©aliser le travail demand√©. Nous avons pu d√©couvrir de nouvelles fonctionnalit√©s telles que l'utilisation des sockets qui est une comp√©tence n√©cessaire √† ma√Ætriser lorsqu‚Äôon souhaite r√©aliser des programmes en r√©seau, ou encore la gestion des √©v√©nements qui est une notion importante √† comprendre lors de la r√©alisation d‚Äôinterface graphique. 

Nous avons ainsi su r√©aliser une application structur√©e et √©volutive o√π chaque √©l√©ment a une organisation pr√©cise.

De plus, ce projet nous a permis de d√©couvrir de nouvelles fa√ßons de d√©velopper en mettant la communication au c≈ìur du projet, ce qui fut tr√®s enrichissant et valorisant.

