<h1 align="center">CPE Lyon - 3ICS - Ann√©e 2021/22
D√©veloppement informatique ‚Äì 2
Projet </h1>

<div align="center">

[![CTF](https://img.shields.io/badge/CPE_LYON-2021-blue.svg)](https://france-cybersecurity-challenge.fr/)
[![CTF](https://img.shields.io/badge/Language-C-yellow.svg)](#)
[![CTF](https://img.shields.io/badge/Category-Network/C-red.svg)](#)

</div>

--- 

## üìù Table des mati√®res

Consignes de l'√©preuve
- [Contexte](#context)
- [Fonctionnalit√©s du syst√®me](#features)
- [Serveur](#features_server)
- [Client](#features_client)
- [Architecture du syst√®me informatis√©](#archi)
- [Gestion des donn√©es](#data_monitoring)
- [Gestion des √©changes client/serveur](#communication)
- [Consignes](#consignes)
- [Travail de base demand√©](#consigne_base)
- [Support](#consigne_support)
- [√âvaluation du travail](#eval)
- [Soutenance](#eval_oral)
- [Rapport](#eval_rapport)

Travail effectu√©
- [Pr√©sentation de l'√©quipe](#team)
- [Organisation du travail dans le groupe](#work_distribution)
- [M√©thodologie de d√©veloppement](#methodology)
- [Avancement du projet et justification des choix](#justify)
- [ Difficult√©s rencontr√©es](#difficulties)
- [R√©gles de communication](#communications_rules)
- [Les difficult√©s](#difficulties)
- [Bilan](#bilan)

Fonctionnement
- [Build](#build)
- [Configuration Serveur](#config_server)
- [Configuration Client](#config_client)
- [Documentation](#doc)

<hr>

## üßê Enonc√© <a name = "context"></a>

l‚ÄôICS (institue of Cognitives Sciences) est un laboratoire interdisciplinaire qui int√®gre l'expertise de
chercheurs des Sciences de la Vie (psychologie cognitive, neurosciences) et de m√©decine (p√©dopsychiatrie, neuro-pediatrie) avec celle de chercheurs des Sciences Humaines et Sociales
(linguistique computationelle et th√©orique et philosophie) pour √©tudier la nature et la sp√©cificit√© de
l'esprit humain.

L‚Äôun des doctorants travaille sur la th√©orie des jeux, √† la fronti√®re de la psychologie et des
math√©matiques, et notamment sur les jeux a somme non constante. Une des illustrations la plus
connue de ces jeux est le dilemme du prisonnier :
 - https://fr.wikipedia.org/wiki/Dilemme_du_prisonnier

Ces deux vid√©os devraient vous √©clairer sur la th√©orie des jeux :
 - https://www.youtube.com/watch?v=StRqGx9ri2I, notamment √† partir de 7‚Äô15‚Äô‚Äô.
 - https://www.youtube.com/watch?v=uijJJ2OczNs&t=913s

Le doctorant, qui n‚Äôest pas un d√©veloppeur, a besoin d‚Äôaccumuler des donn√©es exp√©rimentales. Il a
besoin que des volontaires jouent l‚Äôun contre l‚Äôautre un nombre de fois √† d√©finir, sans jamais savoir
qui sont leurs adversaires.

On d√©finira une partie comme √©tant un certain nombre de rounds. Un round est d√©fini comme une
confrontation trahison-collaboration entre les deux volontaires.

Le doctorant a travaill√© avec l‚Äôing√©nieur d‚Äô√©tudes du laboratoire pour d√©finir un cahier des charges.
L‚Äôing√©nieur d‚Äô√©tudes √† un planning tr√®s charg√©, mais il a amorc√© les projets (le code du serveur et le
code du client). Il a aussi pr√©vu quelques heures pour vous exposer l‚Äô√©tat des projets et le principe
de fonctionnement (gestion des sockets, gestion des connexions, communication asynchrone,
multit√¢che). Il vous pr√©sentera aussi les outils n√©cessaires pour d√©velopper une interface graphique
avec GTK pour l‚Äôapplication cliente.

Vous (le chef de projet) avez √©t√© contact√© pour mettre en place une √©quipe (2 dev + 2 r√©seaux) afin
de d√©velopper les deux applications le plus rapidement possible.


## üßê Fonctionnalit√©s du syst√®me <a name = "features"></a>

Le syst√®me informatique doit √™tre param√©trable par un non-informaticien et doit permettre d‚Äôobtenir
et conserver les r√©sultats des multiples exp√©rimentations.

Vous devez tenir compte du fait qu‚Äôil peut y avoir plusieurs parties simultan√©ment (deux
actuellement, √©tant tenu compte du mat√©riel dont dispose le laboratoire) et que prochainement le
laboratoire disposera encore de quelques ordinateurs suppl√©mentaires.

## üßê Serveur <a name = "features_server"></a>

Le serveur doit √™tre param√©trable. Le fichier de param√©trage permettra de d√©finir l‚Äôadresse IP et le
port sur lequel l‚Äôapplication serveur sera √† l‚Äô√©coute.

Le fichier contiendra aussi le param√©trage n√©cessaire pour d√©finir les r√©gl√©s du jeu : somme engag√©e
a chaque partie, le nombre de parties et d‚Äôautres informations qui vous sembleront n√©cessaires.

A la fin de la partie, le serveur doit garder dans un fichier (le format est √† d√©finir) les choix de
chacun des joueurs, ainsi que le temps de d√©cision et les montants accumul√©s ou perdus.

## üßê Client <a name = "features_client"></a>

Le fichier de param√©trage du client doit contenir l‚Äôadresse IP du serveur ainsi que le port et tout
autre param√©trage qui vous sembleront pertinents.

L‚Äôinterface graphique des clients doit rester tr√®s simple : le cobaye ne doit pas √™tre d√©concentr√© par
des fioritures :
- deux boutons cliquables (Trahir, Collaborer)
- le r√©sultat du round (il doit savoir s‚Äôil a gagn√© ou perdu)
- Il doit √™tre inform√© du d√©but de chaque round.

## üßê Architecture du syst√®me informatis√© <a name = "archi"></a>

Le laboratoire dispose de plusieurs ordinateurs connect√©s entre eux, chacun dans un box afin que les
volontaires ne se rencontrent pas, d‚Äôun ordinateur pour la supervision, d‚Äôun serveur et d‚Äôune
imprimante en r√©seau.

## üßê Gestion des donn√©es <a name = "data_monitoring"></a>

Le serveur central a la charge de l‚Äôensemble des donn√©es. Les donn√©es manipul√©es par le serveur
sont de nature persistante, c‚Äôest-√†-dire qu‚Äôelles doivent survivre √† l‚Äôex√©cution de l‚Äôapplication

## üßê Gestion des √©changes client/serveur <a name = "communication"></a>

Les √©changes entre les clients et le serveur doivent suivre un protocole bien d√©fini pour que le
serveur comprenne les requ√™tes des clients et pour que les clients comprennent les r√©sultats
renvoy√©s par le serveur. Les √©changes doivent √™tre consid√©r√©s au niveau applicatif et au niveau
transport.

Au niveau applicatif, vous devrez d√©finir la structure des messages qui sont √©chang√©s. Vous √™tes
invit√© √† voir la d√©finition d‚Äôun RFC. Le RFC pour le protocole HTTP est l‚Äôun des plus simple a
appr√©hender (https://tools.ietf.org/html/rfc2616).

Au niveau transport, il est impos√© d‚Äôutiliser le protocole TCP/IP. 

## üßê Consignes <a name = "consigne"></a>
## üßê Travail de base demand√© <a name = "consigne_base"></a>

Vous disposez d‚Äôun squelette de programme pour l‚Äôapplication serveur et un autre pour l‚Äôapplication
client. Apr√®s lecture des diff√©rents documents, il faudra le compl√©ter pour fournir :

Aspect r√©seau : un client et un serveur en mode TCP (le squelette de base est op√©rationnel)

Aspect syst√®me :
- un serveur parall√®le. Le code qui vous est fourni utilise des threads pour pouvoir
  g√©rer des connexions en parall√®le et faire du multit√¢che pour le traitement des requ√™tes.
- un client asynchrone capable de traiter les messages du serveur d√®s leurs r√©ceptions.
  Dans tous les cas, avant de commencer √† coder ces questions, faites une analyse des probl√®mes
  que vous voulez r√©soudre et des solutions que vous allez proposer. Si cette analyse est bien faite, le
  codage sera facile. Une bonne analyse (m√™me sans impl√©mentation) dans le rapport et la soutenance
  sera fortement valoris√©e.

  Nous vous conseillons de :
‚Äì bien respecter le cahier des charges 
- bien g√©rer le temps qui vous est imparti 
- bien discuter dans le quadrinome 
- r√©fl√©chir avant de programmer. 
- structurer votre code pour le rendre le plus √©volutif possible. 
- utiliser des assertions 
- bien formalisez le protocole (faite des simulations entre vous). 
- penser aux √©volutions possibles du projet : par exemple l‚Äô√©tat du serveur et des clients
  pourra √™tre supervis√© depuis un poste de‚Ä¶ supervision.

  Tout le code doit bien sur √™tre versionn√©. Comme toujours vous donnerez un acc√®s √† votre d√©p√¥t a
  votre enseignant.

  Vous serez tr√®s attentif aux commentaires et annotations. Il est imp√©ratif de fournir une
  documentation (Javadoc ou Doxygen).

  La pr√©sence d‚Äôassertion dans le code est un imp√©ratif, cependant les tests unitaires ne sont pas
  n√©cessaires.

## üßê Support <a name = "consigne_support"></a>

Vous serez encadr√© pendant tout le projet. Souvenez-vous cependant que votre enseignant n‚Äôest pas
un ‚Äòdegugger‚Äô. Vous pouvez le contacter par mail, mais l‚Äôenseignant n‚Äôest pas 24h/24 devant son
ordinateur : pr√©voyez donc un certain d√©lai dans les r√©ponses. Plus la question est pr√©cise
(n√©cessitant donc une r√©ponse courte), plus la r√©ponse sera rapide.

## üßê √âvaluation du travail <a name = "eval"></a>

## üßê Soutenance <a name = "eval_oral"></a>

Chaque groupe aura 20 minutes, diapositives √† l‚Äôappui, pour pr√©senter son travail. Le groupe
expliquera bri√®vement la r√©partition du travail dans le quadrin√¥me, l‚Äôavancement du projet et les
probl√®mes rencontr√©s. Il devra aussi expliquer et justifier les choix effectu√©s pour les
impl√©mentations. Le jury posera ensuite des questions et demandera √©ventuellement des
d√©monstrations. 

## üßê Rapport <a name = "eval_rapport"></a>

Le quadrinome doit rendre avant la soutenance un rapport de 4 pages (+2 pages d‚Äôannexes)
maximum donnant :
- l‚Äôorganisation du travail dans le groupe ; 
- la m√©thodologie utilis√©e dans le d√©veloppement ; 
- La justification de certains choix et l‚Äô√©valuation de la pertinence √† posteriori; 
- l‚Äô√©tat courant du projet et ce qu‚Äôil reste √† r√©aliser ; 
- les difficult√©s rencontr√©es ; 
- un rapide bilan de ce que vous a apport√© ce projet.

Le rapport ne doit pas redonner des informations pr√©sentes dans ce document. Il doit contenir
suffisamment d‚Äô√©l√©ment pour permettre au doctorant de prendre en main l‚Äôapplication. Le
README.md contiendra les √©l√©ments n√©cessaires pour utiliser les programmes, avec les formats
des fichiers de param√©trages, les formats des fichiers de donn√©es, les commandes n√©cessaires pour
compiler le code source.

Toutes les informations n√©cessaires √† la poursuite du d√©veloppement devront √™tre stock√©es dans des
fichiers de documentation (r√©pertoire doc) pr√©sent dans le projet (description du protocole par
exemple)

<hr>

<h1>Travail effectu√©</h1>

## üßê Pr√©sentation de l'√©quipe <a name = "team"></a>

Notre √©quipe est compos√©e de 4 √©tudiants : 
 - Nicola : Originaire de BTS SNIR
 - Alexis : Originaire de BTS SNIR
 - Tarik : Originaire de BTS SIO Option SLAM
 - Yannis : Originaire de BTS SIO Option SLAM

## üßê Organisation du travail dans le groupe <a name = "work_distribution"></a>

Avant de commencer √† coder, nous avons √©crit sur papier les diff√©rents points cl√©s √† r√©aliser afin d‚Äô√©tablir les objectifs du projet. Une fois le cahier des charges r√©dig√©, nous avons choisi de se r√©partir, entre chaque membre du groupe, les grandes parties du projet
- Partie client :
  - R√©alisation de l‚Äôinterface graphique - Tarik SAGLAMER
  - R√©alisation de la communication client - Alexis REVOL
- Partie serveur :
  - R√©alisation de la logistique du jeu - Nicola PIEMONTESE
  - R√©alisation de la communication serveur - Yannis TEISSIER 
  
Ainsi chaque membre a pu se concentrer sur la r√©alisation de sa partie, cependant les parties √©tant √©troitement li√©es, une communication permanente a √©t√© mise en place afin de s‚Äôassurer de la coh√©rence entre chaque branche du projet.

## üßê M√©thodologie <a name = "methodology"></a>

Afin de s'organiser et de r√©aliser le projet, nous avons commenc√© par √©crire les diff√©rents points √† r√©aliser.

Dans un second temps, nous nous sommes organis√©s sur Github √† l'aide de diff√©rentes branches.

Une branche main vide dans le cas o√π une mauvaise manipulation venait √† √™tre faite. Une branche client pour la partie production client. Une branche serveur pour la partie production serveur. Une branche par personne pour la partie de d√©veloppement.
Nous avons √©galement cr√©√© un serveur discord afin de communiquer efficacement sur le projet.

Notre approche du travail s'est bas√©e sur une m√©thodologie de d√©veloppement agile personnalis√©e. Les heures de cours √©taient principalement utilis√©es pour la correction de bug, la discussion, le code review et la r√©daction des points √† r√©aliser et des am√©liorations √† apporter. Pour la partie d√©veloppement, nous avons utilis√© nos heures libres.
Dans le cas ou un bug √©tait d√©tect√©, deux solutions ont √©t√© propos√©es :
- R√©solution directe par la personne ayant d√©tect√© le bug
- R√©solution par la personne ayant d√©velopp√© le code

R√©guli√®rement, nous faisions des codes reviews nous permettant de mettre en commun le travail r√©alis√© et de voir les changements effectu√©s par les autres membres.

<h5>Distribution des t√¢ches</h5>
```

Partie Graphisme :

- timer visuel pour d√©but de round
- fenetre de choix avec timer, numero de round (bloquer les boutons lorsque choix est deja fait)
- afficher le resultat + timer
- afficher resultat fin de round
- fin de partie (se reconnecter)

Partie communication client:

- connexion en fonction de la configuration du client pour la connexion au serveur (ip port)
- mise en forme des communications (protocole)

Partie communication serveur:

- Mettre en place une configuration pour le serveur (ip port)
- interpretation des communications (protocole)

Partie logique du jeu:

- lire la configuration du jeu
- gerer le nombre de joueurs
- envoyer les instructions de d√©but si le nombre de joueurs est bon
- attendre la reponse
- afficher les resultats
- stocker dans un fichier les resultats
- relancer un round si le nombre de rounds est inferieur au nombre de rounds dans le fichier de configuration
```


## üßê Avancement du projet et justification des choix <a name = "justify"></a>

<h4>Justification des choix</h4>

Pour √©tablir la communication entre un client et le serveur, nous avons choisi d‚Äôutiliser les sockets afin de transmettre des structures contenant les informations pertinentes √† manipuler et traiter. Le client et le serveur poss√©dants les m√™mes structures cela permet de s‚Äôassurer que la forme de l‚Äôinformation envoy√©e sera la m√™me que celle de l‚Äôinformation attendue √† la r√©ception. Nous avons choisi d‚Äô√©tablir un protocole de communication entre le client et le serveur afin que la communication entre chaque partie suive une ligne identique.

Pour r√©aliser l‚Äôinterface graphique, nous avons utilis√© GTK qui permet de r√©aliser des fen√™tres graphiques personnalisables ce qui est id√©al pour la r√©alisation du plateau de jeu. L‚Äôinterface est compos√©e des boutons pour jouer (trahir et collaborer) ainsi que de zones de textes permettant d‚Äôafficher les informations utiles pour le joueur. Ainsi lorsque dans le protocole de communication client/serveur nous souhaitons transmettre le choix de jeu r√©alis√© par le client nous √©coutons sur quel bouton le joueur √† cliqu√© afin d‚Äôenregistrer et de traiter l‚Äôinformation. Lorsque le client r√©ceptionne des informations du serveur il peut alors les fournir √† l‚Äôinterface graphique afin de les afficher

Pour r√©aliser la logistique du jeu, nous avons choisi d‚Äô√©tablir des r√®gles qui permettent ainsi de traiter les informations  de mani√®re efficace en s‚Äôassurant de conserver leur pertinence. Nous avons √©galement choisi de r√©aliser des fichiers de configurations  lues au lancement du jeu, ceux-ci contenant des informations telles que l‚Äôadresse du serveur, le port, des r√®gles du jeu... Cela permet, en cas de changement de l‚Äôadresse du serveur ou de certaines r√®gles du jeu, de ne pas avoir √† modifier les programmes ce qui facilite l‚Äô√©volutivit√© et l‚Äôadaptation aux changements des programmes.

<h4>Justification des choix</h4>

Aujourd‚Äôhui le client et le serveur sont capables de lire leurs fichiers de configuration r√©ceptifs, le serveur √©coute les connexions entrantes et les place dans une file d‚Äôattente. Lorsque 2 clients sont disponibles dans la file d'attente, il lance la communication permettant de jouer en fournissant les informations de d√©but de partie au client.

Ainsi lorsque le client lance le jeu il est inform√© par un message que la partie se charge le temps que le serveur lui informe qu‚Äôune partie va d√©buter. Une fois le jeu commenc√© le client indique que le joueur peut jouer en cliquant sur un bouton, puis lors d‚Äôun clic il envoie l‚Äôinformation au serveur. Le serveur attend de recevoir les r√©ponses des 2 joueurs, le joueur est alors inform√© qu‚Äôil est en attente de la r√©ponse de l‚Äôadversaire s‚Äôil n‚Äôa pas encore jou√©.

Lorsque le serveur a re√ßu les r√©ponses des 2 joueurs, ils les traitent afin d‚Äô√©tablir un score et il transmet au client le r√©sultat du round, le client peut alors fournir √† l‚Äôinterface graphique le r√©sultat du round (choix de l‚Äôadversaire, score de chaque joueur, etc‚Ä¶) afin de les afficher pour que le joueur soit inform√© du r√©sultat du round et de ce qui a √©t√© effectu√©. Le joueur peut observer les r√©sultats du round (durant 3 secondes) puis il est inform√© qu‚Äôun nouveau round commence et le sch√©ma se r√©p√®te.

Lorsque le serveur indique au client que la partie est termin√©e, le client affich√© sur l‚Äôinterface graphique un bouton pour rejouer ainsi que le nom du gagnant, si le joueur clique dessus alors le client est replac√© dans la file d‚Äôattente du serveur, s‚Äôil quitte la partie le serveur ferme la connexion du client.

Ainsi plusieurs joueurs peuvent jouer au dilemme du prisonnier en r√©seau (multi-joueurs) et peuvent recommencer des parties afin de tomber contre d‚Äôautres adversaires !

Enfin les r√©sultats d‚Äôune partie sont aussi stock√©s dans un fichier CSV pouvant √™tre lu avec un logiciel de tableur comme Excel.

## üßê R√®gles de communication <a name = "communications_rules"></a>

Pour la communication, nous avons d√©fini un protocole personnalis√©.

```
Permet d'envoyer au client un identifiant pour le serveur et un identifiant local servant dans la partie client afin de d√©finir le joueur 1 et le joueur 2 
id <id_client>:<id_local>

Permet d'envoyer le num√©ro de partie au client
party <id_party>

Permet d'envoyer un status (status de la partie ou status du client)
status <status>

Permet de communiquer les r√©ponses des clients au serveur 
<answer_struct>

Permet de communiquer le recapitulatif d'un round au client
<round_struct>

Permet de communiquer l'id du winner au client
winner <int>

Permet de communiquer le recapitualtif de la partie au client
<recap_party>
```

## üßê Difficult√©s rencontr√©es <a name = "difficulties"></a>

Durant la r√©alisation du projet nous avons √©t√© confront√©s √† diff√©rentes difficult√©s. Tout d‚Äôabord nous avons rencontr√© des difficult√©s li√©es √† la programmation. En effet nous avons d√ª nous coordonner puisque chacun d‚Äôentre nous √† des mani√®res diff√©rentes de programmer, ainsi nous avons d√ª adapter certaines parties du code afin qu'elles fonctionnent avec le reste du projet. De plus, nous avons d√ª r√©soudre plusieurs probl√®mes li√©s √† des bugs de m√©moire.

Nous avons aussi pass√© du temps √† √©tablir une communication entre le serveur et les clients stables . En effet, nous devions r√©aliser une connexion permettant l‚Äôenvoi de structure complexe, avec un protocole clair et simple.

D'autres difficult√©s li√©es √† la m√©thodologie sont aussi apparues. Ainsi puisque que toutes nos parties sont finalement li√©es entre elles, il nous est apparu n√©cessaire de bien se coordonner et de se tenir √† jour des modifications des autres membres afin que les changements ne perturbent pas l'avanc√©e des autres.

Concernant la partie graphique nous nous sommes mis d‚Äôaccord sur une interface graphique qui soit simple et avons d√ª l'adapter afin de pouvoir la faire communiquer avec le client.

Finalement plusieurs difficult√©s √©taient dues au fait qu‚Äôaucun de nous quatre n‚Äôavait auparavant d√©j√† programm√© d‚Äôinterfaces graphiques ou de communication client-serveur en C.

## üßê Bilan <a name = "bilan"></a>

Au cours de ce projet nous avons su mettre en avant les comp√©tences acquises au cours de ce module de d√©veloppement et les compl√©ter en recherchant des solutions pour r√©soudre des probl√®mes sp√©cifiques au projet. Ce projet a n√©cessit√© de l‚Äôautonomie sur les r√©flexions et les choix des m√©thodes √† apporter pour r√©aliser le travail demand√©. Nous avons pu d√©couvrir de nouvelles fonctionnalit√©s telles que l'utilisation des sockets qui est une comp√©tence n√©cessaire √† ma√Ætriser lorsqu‚Äôon souhaite r√©aliser des programmes en r√©seau, ou encore la gestion des √©v√©nements qui est une notion importante √† comprendre lors de la r√©alisation d‚Äôinterface graphique.

Nous avons ainsi su r√©aliser une application structur√©e et √©volutive o√π chaque √©l√©ment a une organisation pr√©cise.

De plus, ce projet nous a permis de d√©couvrir de nouvelles fa√ßons de d√©velopper en mettant la communication au c≈ìur du projet, ce qui fut tr√®s enrichissant et valorisant.


<hr>

<h1>Fonctionnement</h1>

## üßê Build <a name = "build"></a>

Pr√©paration du build :
- Installation de la librairie GTK+3
- Installation de cmake
- Installation de make
- Installation de GCC ou un autre compilateur
- Installation de git
- Installation de Doxygen

Afin de compiler le projet nous vous proposons deux solutions :

Via un script adapt√© √† la machine que vous utilisez (Linux, MacOS)

Pour Linux et MacOS, il faut choisir le script "build_unix.sh"

Il faut ensuite ouvrir un terminal et lancer le script.
```bash
./build_unix>.sh
```

Dans le dossier *output*, il y aura un executable "client" et un executable "server".

Dans le dossier "client_config", vous y trouverez les fichiers de configuration du client.

Et dans le dossier "server_config", vous y trouverez les fichiers de configuration du serveur.

Via la ligne de commande.

Unix
```
cd server
mkdir build
cd build
cmake ..
make all
cp server ../server

cd ..

cd client
mkdir build
cd build
cmake ..
make all
cp client ../client
```

## üßê Configuration Serveur <a name = "config_server"></a>

Il existe deux fichiers de configurations pour le serveur :
- server_config/rules_config.json
- server_config/server_config.json

Le fichier *server_config.json* permet de configurer la partie √©coute du serveur.

````json
{
  "ip_address": "127.0.0.1",
  "port": "30000"
}
````

Il suffit de modifier les valeurs de l'ip_address avec l'ip d'√©coute et du port avec le port d'√©coute.

Le fichier *rules_config.json* permet de configurer les r√®gles du jeu.

````json
{
    "nb_round": "3",
    "default_wallet": "0",

    "trahison_win": "-5",
    "trahison_loose": "-5",

    "collab_win": "-1",
    "collab_loose": "-1",
    
    "trahison_collab_win": "0",
    "trahison_collab_loose": "-10"    
}
````

*nb_round* correspond au nombre de round que la partie aura.
```
"nb_round": "3"
```

*default_wallet* correspond √† la valeur de d√©part du porte-monnaie de chaque joueur.
```
"default_wallet": "0"
```

*trahison_win* correspond √† la valeur de gain du joueur en cas de victoire contre un trahison.
```
"trahison_win": "-5"
```

*trahison_loose* correspond √† la valeur de perte du joueur en cas de d√©faite contre un trahison.
```
"trahison_loose": "-5"
```

*collab_win* correspond √† la valeur de gain du joueur en cas de victoire contre un collab.
```
"collab_win": "-1"
```

*collab_loose* correspond √† la valeur de perte du joueur en cas de d√©faite contre un collab.
```
"collab_loose": "-1"
```

*trahison_collab_win* correspond √† la valeur de gain du joueur en cas de victoire contre un trahison et un collab.
```
"trahison_collab_win": "0"
```

*trahison_collab_loose* correspond √† la valeur de perte du joueur en cas de d√©faite contre un trahison et un collab.
```
"trahison_collab_loose": "-10"
```

## üßê Configuration Client <a name = "config_client"></a>
Pour la configuration du client il n'existe qu'un seul fichier de configuration:
- client_config/config.json

Le fichier *config.json* permet de configurer la partie connexion au serveur.

````json
{
  "ip_address": "127.0.0.1",
  "port": "30000"
}
````

Il suffit de modifier les valeurs de l'ip_address avec l'ip du serveur et du port du serveur.

## üßê Documentation <a name = "doc"></a>

Pour g√©n√©rer la documentation du projet, il suffit de lancer la commande suivante :
```bash
./build_unix_doc.sh
```

Via la ligne de commande.

Unix
```
cd client || exit
mkdir build
cd build || exit
cmake ..
make doc

cd ../..

cd server || exit
mkdir build
cd build || exit
cmake ..
make doc
cd ../..

mkdir documentation
mkdir -r documentation/client
cp -r client/doc/html documentation/client
mkdir -r documentation/server
cp -r server/doc/html documentation/server
```


Pour acc√©der √† la documentation, il suffit de lancer le fichier *index.html* du dossier *documentation/client* ou *documentation/server* dans un navigateur web.
