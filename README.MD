<h1 align="center">CPE Lyon - 3ICS - AnnÃ©e 2021/22
DÃ©veloppement informatique â€“ 2
Projet </h1>

<div align="center">

[![CTF](https://img.shields.io/badge/CPE_LYON-2021-blue.svg)](https://france-cybersecurity-challenge.fr/)
[![CTF](https://img.shields.io/badge/Language-C-yellow.svg)](#)
[![CTF](https://img.shields.io/badge/Category-Network/C-red.svg)](#)

</div>

--- 

## ğŸ“ Table des matiÃ¨res

Consignes de l'Ã©preuve
- [Contexte](#context)
- [FonctionnalitÃ©s du systÃ¨me](#features)
- [Serveur](#features_server)
- [Client](#features_client)
- [Architecture du systÃ¨me informatisÃ©](#archi)
- [Gestion des donnÃ©es](#data_monitoring)
- [Gestion des Ã©changes client/serveur](#communication)
- [Consignes](#consignes)
- [Travail de base demandÃ©](#consigne_base)
- [Support](#consigne_support)
- [Ã‰valuation du travail](#eval)
- [Soutenance](#eval_oral)
- [Rapport](#eval_rapport)

Travail effectuÃ©
- [L'Ã©quipe](#team)
- [RÃ©partition du travail](#work_distribution)
- [MÃ©thodologie](#methodology)
- [Justification des choix](#justify)
- [RÃ©gles de communication](#communications_rules)
- [Les difficultÃ©s](#difficulties)
- [Bilan](#bilan)

Fonctionnement
- [Build](#build)
- [Configuration Serveur](#config_server)
- [Configuration Client](#config_client)
- [Documentation](#doc)

## ğŸ§ EnoncÃ© <a name = "context"></a>

lâ€™ICS (institue of Cognitives Sciences) est un laboratoire interdisciplinaire qui intÃ¨gre l'expertise de
chercheurs des Sciences de la Vie (psychologie cognitive, neurosciences) et de mÃ©decine (pÃ©dopsychiatrie, neuro-pediatrie) avec celle de chercheurs des Sciences Humaines et Sociales
(linguistique computationelle et thÃ©orique et philosophie) pour Ã©tudier la nature et la spÃ©cificitÃ© de
l'esprit humain.

Lâ€™un des doctorants travaille sur la thÃ©orie des jeux, Ã  la frontiÃ¨re de la psychologie et des
mathÃ©matiques, et notamment sur les jeux a somme non constante. Une des illustrations la plus
connue de ces jeux est le dilemme du prisonnier :
 - https://fr.wikipedia.org/wiki/Dilemme_du_prisonnier

Ces deux vidÃ©os devraient vous Ã©clairer sur la thÃ©orie des jeux :
 - https://www.youtube.com/watch?v=StRqGx9ri2I, notamment Ã  partir de 7â€™15â€™â€™.
 - https://www.youtube.com/watch?v=uijJJ2OczNs&t=913s

Le doctorant, qui nâ€™est pas un dÃ©veloppeur, a besoin dâ€™accumuler des donnÃ©es expÃ©rimentales. Il a
besoin que des volontaires jouent lâ€™un contre lâ€™autre un nombre de fois Ã  dÃ©finir, sans jamais savoir
qui sont leurs adversaires.

On dÃ©finira une partie comme Ã©tant un certain nombre de rounds. Un round est dÃ©fini comme une
confrontation trahison-collaboration entre les deux volontaires.

Le doctorant a travaillÃ© avec lâ€™ingÃ©nieur dâ€™Ã©tudes du laboratoire pour dÃ©finir un cahier des charges.
Lâ€™ingÃ©nieur dâ€™Ã©tudes Ã  un planning trÃ¨s chargÃ©, mais il a amorcÃ© les projets (le code du serveur et le
code du client). Il a aussi prÃ©vu quelques heures pour vous exposer lâ€™Ã©tat des projets et le principe
de fonctionnement (gestion des sockets, gestion des connexions, communication asynchrone,
multitÃ¢che). Il vous prÃ©sentera aussi les outils nÃ©cessaires pour dÃ©velopper une interface graphique
avec GTK pour lâ€™application cliente.

Vous (le chef de projet) avez Ã©tÃ© contactÃ© pour mettre en place une Ã©quipe (2 dev + 2 rÃ©seaux) afin
de dÃ©velopper les deux applications le plus rapidement possible.


## ğŸ§ FonctionnalitÃ©s du systÃ¨me <a name = "features"></a>

Le systÃ¨me informatique doit Ãªtre paramÃ©trable par un non-informaticien et doit permettre dâ€™obtenir
et conserver les rÃ©sultats des multiples expÃ©rimentations.

Vous devez tenir compte du fait quâ€™il peut y avoir plusieurs parties simultanÃ©ment (deux
actuellement, Ã©tant tenu compte du matÃ©riel dont dispose le laboratoire) et que prochainement le
laboratoire disposera encore de quelques ordinateurs supplÃ©mentaires.

## ğŸ§ Serveur <a name = "features_server"></a>

Le serveur doit Ãªtre paramÃ©trable. Le fichier de paramÃ©trage permettra de dÃ©finir lâ€™adresse IP et le
port sur lequel lâ€™application serveur sera Ã  lâ€™Ã©coute.

Le fichier contiendra aussi le paramÃ©trage nÃ©cessaire pour dÃ©finir les rÃ©glÃ©s du jeu : somme engagÃ©e
a chaque partie, le nombre de parties et dâ€™autres informations qui vous sembleront nÃ©cessaires.

A la fin de la partie, le serveur doit garder dans un fichier (le format est Ã  dÃ©finir) les choix de
chacun des joueurs, ainsi que le temps de dÃ©cision et les montants accumulÃ©s ou perdus.

## ğŸ§ Client <a name = "features_client"></a>

Le fichier de paramÃ©trage du client doit contenir lâ€™adresse IP du serveur ainsi que le port et tout
autre paramÃ©trage qui vous sembleront pertinents.

Lâ€™interface graphique des clients doit rester trÃ¨s simple : le cobaye ne doit pas Ãªtre dÃ©concentrÃ© par
des fioritures :
- deux boutons cliquables (Trahir, Collaborer)
- le rÃ©sultat du round (il doit savoir sâ€™il a gagnÃ© ou perdu)
- Il doit Ãªtre informÃ© du dÃ©but de chaque round.

## ğŸ§ Architecture du systÃ¨me informatisÃ© <a name = "archi"></a>

Le laboratoire dispose de plusieurs ordinateurs connectÃ©s entre eux, chacun dans un box afin que les
volontaires ne se rencontrent pas, dâ€™un ordinateur pour la supervision, dâ€™un serveur et dâ€™une
imprimante en rÃ©seau.

## ğŸ§ Gestion des donnÃ©es <a name = "data_monitoring"></a>

Le serveur central a la charge de lâ€™ensemble des donnÃ©es. Les donnÃ©es manipulÃ©es par le serveur
sont de nature persistante, câ€™est-Ã -dire quâ€™elles doivent survivre Ã  lâ€™exÃ©cution de lâ€™application

## ğŸ§ Gestion des Ã©changes client/serveur <a name = "communication"></a>

Les Ã©changes entre les clients et le serveur doivent suivre un protocole bien dÃ©fini pour que le
serveur comprenne les requÃªtes des clients et pour que les clients comprennent les rÃ©sultats
renvoyÃ©s par le serveur. Les Ã©changes doivent Ãªtre considÃ©rÃ©s au niveau applicatif et au niveau
transport.

Au niveau applicatif, vous devrez dÃ©finir la structure des messages qui sont Ã©changÃ©s. Vous Ãªtes
invitÃ© Ã  voir la dÃ©finition dâ€™un RFC. Le RFC pour le protocole HTTP est lâ€™un des plus simple a
apprÃ©hender (https://tools.ietf.org/html/rfc2616).

Au niveau transport, il est imposÃ© dâ€™utiliser le protocole TCP/IP. 

## ğŸ§ Consignes <a name = "consigne"></a>
## ğŸ§ Travail de base demandÃ© <a name = "consigne_base"></a>

Vous disposez dâ€™un squelette de programme pour lâ€™application serveur et un autre pour lâ€™application
client. AprÃ¨s lecture des diffÃ©rents documents, il faudra le complÃ©ter pour fournir :

Aspect rÃ©seau : un client et un serveur en mode TCP (le squelette de base est opÃ©rationnel)

Aspect systÃ¨me :
- un serveur parallÃ¨le. Le code qui vous est fourni utilise des threads pour pouvoir
  gÃ©rer des connexions en parallÃ¨le et faire du multitÃ¢che pour le traitement des requÃªtes.
- un client asynchrone capable de traiter les messages du serveur dÃ¨s leurs rÃ©ceptions.
  Dans tous les cas, avant de commencer Ã  coder ces questions, faites une analyse des problÃ¨mes
  que vous voulez rÃ©soudre et des solutions que vous allez proposer. Si cette analyse est bien faite, le
  codage sera facile. Une bonne analyse (mÃªme sans implÃ©mentation) dans le rapport et la soutenance
  sera fortement valorisÃ©e.

  Nous vous conseillons de :
â€“ bien respecter le cahier des charges 
- bien gÃ©rer le temps qui vous est imparti 
- bien discuter dans le quadrinome 
- rÃ©flÃ©chir avant de programmer. 
- structurer votre code pour le rendre le plus Ã©volutif possible. 
- utiliser des assertions 
- bien formalisez le protocole (faite des simulations entre vous). 
- penser aux Ã©volutions possibles du projet : par exemple lâ€™Ã©tat du serveur et des clients
  pourra Ãªtre supervisÃ© depuis un poste deâ€¦ supervision.

  Tout le code doit bien sur Ãªtre versionnÃ©. Comme toujours vous donnerez un accÃ¨s Ã  votre dÃ©pÃ´t a
  votre enseignant.

  Vous serez trÃ¨s attentif aux commentaires et annotations. Il est impÃ©ratif de fournir une
  documentation (Javadoc ou Doxygen).

  La prÃ©sence dâ€™assertion dans le code est un impÃ©ratif, cependant les tests unitaires ne sont pas
  nÃ©cessaires.

## ğŸ§ Support <a name = "consigne_support"></a>

Vous serez encadrÃ© pendant tout le projet. Souvenez-vous cependant que votre enseignant nâ€™est pas
un â€˜deguggerâ€™. Vous pouvez le contacter par mail, mais lâ€™enseignant nâ€™est pas 24h/24 devant son
ordinateur : prÃ©voyez donc un certain dÃ©lai dans les rÃ©ponses. Plus la question est prÃ©cise
(nÃ©cessitant donc une rÃ©ponse courte), plus la rÃ©ponse sera rapide.

## ğŸ§ Ã‰valuation du travail <a name = "eval"></a>

## ğŸ§ Soutenance <a name = "eval_oral"></a>

Chaque groupe aura 20 minutes, diapositives Ã  lâ€™appui, pour prÃ©senter son travail. Le groupe
expliquera briÃ¨vement la rÃ©partition du travail dans le quadrinÃ´me, lâ€™avancement du projet et les
problÃ¨mes rencontrÃ©s. Il devra aussi expliquer et justifier les choix effectuÃ©s pour les
implÃ©mentations. Le jury posera ensuite des questions et demandera Ã©ventuellement des
dÃ©monstrations. 

## ğŸ§ Rapport <a name = "eval_rapport"></a>

Le quadrinome doit rendre avant la soutenance un rapport de 4 pages (+2 pages dâ€™annexes)
maximum donnant :
- lâ€™organisation du travail dans le groupe ; 
- la mÃ©thodologie utilisÃ©e dans le dÃ©veloppement ; 
- La justification de certains choix et lâ€™Ã©valuation de la pertinence Ã  posteriori; 
- lâ€™Ã©tat courant du projet et ce quâ€™il reste Ã  rÃ©aliser ; 
- les difficultÃ©s rencontrÃ©es ; 
- un rapide bilan de ce que vous a apportÃ© ce projet.

Le rapport ne doit pas redonner des informations prÃ©sentes dans ce document. Il doit contenir
suffisamment dâ€™Ã©lÃ©ment pour permettre au doctorant de prendre en main lâ€™application. Le
README.md contiendra les Ã©lÃ©ments nÃ©cessaires pour utiliser les programmes, avec les formats
des fichiers de paramÃ©trages, les formats des fichiers de donnÃ©es, les commandes nÃ©cessaires pour
compiler le code source.

Toutes les informations nÃ©cessaires Ã  la poursuite du dÃ©veloppement devront Ãªtre stockÃ©es dans des
fichiers de documentation (rÃ©pertoire doc) prÃ©sent dans le projet (description du protocole par
exemple)



## ğŸ§ L'Ã©quipe <a name = "team"></a>

Notre Ã©quipe est composÃ©e de 4 Ã©tudiants : 
 - Nicola : Originaire de BTS ...
 - Alexis : Originaire de BTS ...
 - Tarik : Originaire de BTS ...
 - Yannis : Originaire de BTS SIO Option SLAM

## ğŸ§ RÃ©partition du travail <a name = "work_distribution"></a>

Pour commencer, nous avons constituÃ© deux groupes de travail : 
 - Tarik et Alexis : Partie client
 - Yannis et Nicola : Partie serveur

Pour la partie client, Tarik s'est occupÃ© de la partie GUI et Alexis de la partie de communication.

Pour la partie serveur, Nicola s'est occupÃ© de la partie logique du jeu, et Yannis de la communication.


## ğŸ§ MÃ©thodologie <a name = "methodology"></a>

Afin de s'organiser et de rÃ©aliser le projet, nous avons commencÃ© par Ã©crire les diffÃ©rents points Ã  rÃ©aliser.

```

graphisme :

- timer visuel pour dÃ©but de round
- fenetre de choix avec timer, numero de round (bloquer les boutons lorsque choix est deja fait)
- afficher le resultat + timer
- afficher resultat fin de round
- fin de partie (se reconnecter)

envoi depuis le client:

- connexion config serveur (ip port)
- mise en forme des communications

reception cotÃ© serveur:

- setup config serveur (ip port)
- interpretation des communications

regles du jeu:

- lire la config
- gerer le nombre de joueurs
- envoyer les instructions de dÃ©but si nb joueurs ok
- attendre la reponse
- afficher les resultats
- stocker en fichier les resultats
- relance un round si nb round < nb round config
```

Dans un second temps, nous nous sommes organisÃ©s sur Github Ã  l'aide de diffÃ©rentes branches.

Une branche main vide dans le cas ou une mauvaise manipulation venait Ã  Ãªtre faite.
Une branche client pour la partie production client.
Une branche serveur pour la partie production serveur.

Une branche par personne pour la partie de dÃ©veloppement.

Nous avons Ã©galement crÃ©Ã©e un serveur discord afin de communiquer efficacement sur le projet.

Notre approche du travail s'est basÃ©e sur une mÃ©thodologie de dÃ©veloppement agile personnalisÃ©e.

Les heures de cours Ã©taient principalement utilisÃ©es pour la correction de bug, la discussion, le code review et la rÃ©daction des points Ã  rÃ©aliser et des amÃ©liorations Ã  apporter.

Pour la partie dÃ©veloppement, nous avons utilisÃ© nos heures libre.

Dans le cas ou un bug Ã©tait dÃ©tectÃ©, deux solutions ont Ã©tÃ© proposÃ©es :
- RÃ©solution directe par la personne ayant detÃ©ctÃ© le bug
- RÃ©solution par la personne ayant dÃ©veloppÃ© le code

RÃ©guliÃ¨rement, nous faisions des codes reviews nous permettant de voir les changements effectuÃ©s par les autres membres. 


## ğŸ§ Justification des choix <a name = "justify"></a>
## ğŸ§ RÃ©gles de communication <a name = "communications_rules"></a>

Pour la communication, nous avons dÃ©fini un protocole personnalisÃ©.

```
Permet d'envoyer au client un identifiant pour le serveur et un identifiant local servant dans la partie client afin de dÃ©finir le joueur 1 et le joueur 2 
id <id_client>:<id_local>

Permet d'envoyer le numÃ©ro de partie au client
party <id_party>

Permet d'envoyer un status (status de la partie ou status du client)
status <status>

Permet de communiquer les rÃ©ponses des clients au serveur 
<answer_struct>

Permet de communiquer le recapitulatif d'un round au client
<round_struct>

Permet de communiquer l'id du winner au client
winner <int>

Permet de communiquer le recapitualtif de la partie au client
<recap_party>
```

## ğŸ§ Les difficultÃ©s <a name = "difficulties"></a>

DifficultÃ©s liÃ©es au code :
- DiffÃ©rentes maniÃ¨res d'Ã©crire le code
- L'adaptation du code de chaque personne au projet
- Les diffÃ©rents types de bugs de mÃ©moire
- L'envoi de structures complexes 

DifficultÃ©s liÃ©es Ã  la communication :
- Les diffÃ©rents types de communication existant
- DÃ©finir un protocole personnalisÃ© clair et simple

DifficultÃ©s liÃ©es Ã  la mÃ©thodologie :
- Se coordonner avec les autres membres
- Se tenir Ã  jour avec les autres membres
- VÃ©rifier les changements des autres membres afin de pouvoir rÃ©aliser les changements

DifficultÃ©s liÃ©es Ã  la nouveautÃ© :
- La mise en place d'un serveur
- La mise en place d'un client
- La communication avec le serveur et le client
- Mise en place d'une interface graphique

DifficultÃ©s liÃ©es Ã  la partie graphique :
- Choix du style de l'interface graphique
- SimplicitÃ© de l'interface graphique
- Brancher l'interface graphique au client

## ğŸ§ Bilan <a name = "bilan"></a>

MalgrÃ© les diffÃ©rentes difficultÃ©s rencontrÃ©es, nous avons rÃ©ussi Ã  rÃ©aliser le projet.
Nous en tirerons des bÃ©nÃ©fices, et nous adopterons une mÃ©thodologie diffÃ©rente en tirant profit des diffÃ©rentes difficultÃ©s rencontrÃ©es.

Ce projet nous aura appris Ã  traduire un concept en programme, en se basant sur le dÃ©veloppement d'un client, un serveur et un interface graphique.

Nous partions de simples connaissances basique en c et aujourd'hui nous avons Ã©tÃ© capable de mettre Ã  l'Ã©preuve nos connaissances afin de fournir un rendu final.

## ğŸ§ Build <a name = "build"></a>

PrÃ©paration du build :
- Installation de la librairie GTK+3
- Installation de cmake
- Installation de make
- Installation de GCC

Afin de compiler le projet nous vous proposons deux solutions :

Via un script adaptÃ© Ã  la machine que vous utilisez (Linux, Windows, MacOS)

Pour windows, il faut choisir le script "build_windows.bat"
Pour Linux et MacOS, il faut choisir le script "build_unix.sh"

Dans les deux cas, il faut ouvrir un terminal et lancer le script.
```bash
./build_<environnement>.sh/bat
```

Via la ligne de commande.

## ğŸ§ Configuration Serveur <a name = "config_server"></a>
## ğŸ§ Configuration Client <a name = "config_client"></a>
## ğŸ§ Documentation Client <a name = "doc"></a>
